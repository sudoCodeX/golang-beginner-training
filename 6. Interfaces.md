## ðŸ§© Chapter 6: Structs and Interfaces

### 1. Structs: Custom Data Types

A **Struct** (structure) is a collection of fields (data) grouped together to form a single entity. It's similar to a class in other languages, but it only contains dataâ€”no methods directly defined within it.

#### Example: Defining and Using a Struct

Go

```
package main

import "fmt"

// Define a new Struct type called 'Person'
type Person struct {
    FirstName string
    LastName  string
    Age       int
}

func main() {
    // 1. Create and initialize a struct instance
    p1 := Person{
        FirstName: "Alice",
        LastName:  "Smith",
        Age:       30,
    }

    // 2. Access fields using dot notation
    fmt.Println(p1.FirstName, "is", p1.Age, "years old.")
    
    // 3. Using struct pointers (common in Go)
    p2 := &Person{FirstName: "Bob"} // Create a pointer to a struct
    fmt.Println("Pointer access:", p2.FirstName) // Go automatically dereferences the pointer
}
```

---

### 2. Methods: Struct Behavior

In Go, methods are simply **functions** that have a defined **receiver** argument. This allows you to attach behavior (functions) to a specific type (like a struct).

#### Example: Adding a Method

Go

```
// The receiver (p Person) links this function to the Person struct
func (p Person) FullName() string {
    return p.FirstName + " " + p.LastName
}

func main() {
    p1 := Person{FirstName: "Alice", LastName: "Smith"}
    
    // Call the method using dot notation on the struct instance
    name := p1.FullName() 
    fmt.Println("Full Name:", name) // Output: Full Name: Alice Smith
}
```

---

### 3. Interfaces: Achieving Polymorphism

An **Interface** is a collection of **method signatures**. It defines a _contract_: any type (like a struct) that implements **all** the methods declared in the interface is said to implement that interface.

**ðŸ”¥ Key Concept:** Implementation is **implicit**â€”no `implements` keyword is needed!

#### Example: Interface Contract

Go

```
package main

import "fmt"

// 1. Define the interface contract
type Greeter interface {
    Speak() string // Requires a method named Speak() that returns a string
}

type Cat struct {
    Name string
}

type Dog struct {
    Name string
}

// 2. Cat implicitly implements Greeter
func (c Cat) Speak() string {
    return "Meow! My name is " + c.Name
}

// 3. Dog implicitly implements Greeter
func (d Dog) Speak() string {
    return "Woof! My name is " + d.Name
}

// A function that accepts ANY type that satisfies the Greeter interface
func SayHello(g Greeter) {
    fmt.Println(g.Speak())
}

func main() {
    c := Cat{Name: "Whiskers"}
    d := Dog{Name: "Buddy"}
    
    // Both Cat and Dog can be passed to SayHello!
    SayHello(c) // Output: Meow! My name is Whiskers
    SayHello(d) // Output: Woof! My name is Buddy
}
```

The `Greeter` interface allows us to write flexible code (`SayHello`) that works with any struct, as long as that struct has the required `Speak()` method.

---

### ðŸ”— Reference

- **Go Tour - Methods:** [https://go.dev/tour/methods/1](https://www.google.com/search?q=https://go.dev/tour/methods/1)
    
- **Go Tour - Interfaces:** [https://go.dev/tour/methods/9](https://go.dev/tour/methods/9)