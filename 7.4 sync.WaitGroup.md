## ⚡ The `sync.WaitGroup`: Waiting for Completion ⏳

A **`sync.WaitGroup`** is a simple but powerful synchronization tool used to **block** the execution of the main Goroutine until a specific number of other Goroutines have finished their work. It's typically used when you launch several independent workers and need to wait for all of them before proceeding.

### WaitGroup Operations

The `WaitGroup` maintains an internal counter, and its usage involves three core methods:

|**Method**|**Purpose**|**Description**|
|---|---|---|
|**`Add(n)`**|Counter Increaser|Increases the internal counter by `n` (usually 1 for each new Goroutine). Must be called _before_ launching the Goroutine.|
|**`Done()`**|Counter Decreaser|Decreases the counter by 1. Should be called by the Goroutine when it finishes its task. Idiomatically, this is done using `defer`.|
|**`Wait()`**|Blocker|Blocks the calling Goroutine (usually `main`) until the internal counter reaches zero.|

### Coordinating Worker Goroutines

The key pattern is to call `Add()` before `go func()` and use `defer wg.Done()` inside the Goroutine to ensure the counter is decremented even if the Goroutine panics.

#### Example: Waiting for Multiple Workers

Go

```
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    // 1. Crucial step: Ensure the counter is decremented when the function exits
    defer wg.Done() 

    fmt.Printf("Worker %d starting...\n", id)
    time.Sleep(time.Duration(id) * 200 * time.Millisecond) // Simulate work
    fmt.Printf("Worker %d finished.\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    fmt.Println("Launching workers...")

    for i := 1; i <= 3; i++ {
        // 2. Increment the counter before launching the Goroutine
        wg.Add(1) 
        go worker(i, &wg) // Pass the WaitGroup pointer
    }

    // 3. Block here until the counter reaches zero (3 Done() calls received)
    wg.Wait() 
    fmt.Println("All workers have successfully completed their tasks.")
}
```

**Benefit:** Without `wg.Wait()`, the `main` function would exit immediately after launching the three workers, likely terminating the program before any of the workers could finish their tasks.