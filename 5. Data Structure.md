
## ðŸ“¦ Chapter 5: Arrays, Slices, and Maps (Data Structures)

Go provides three primary data structures for holding collections of data. Understanding the subtle difference between **Arrays** and **Slices** is crucial.

### 1. Arrays: Fixed Size

An **Array** is a numbered sequence of elements of a specific type. Its size is **fixed** at the time of declaration and cannot be changed. This makes them less flexible for general use.

#### Example: Declaring an Array

Go

```
package main

import "fmt"

func main() {
    // Array of 5 integers
    var a [5]int 
    a[4] = 100 // Arrays are zero-indexed
    
    fmt.Println("Array a:", a)      // Output: Array a: [0 0 0 0 100]
    fmt.Println("Length of a:", len(a)) // Length of a: 5
    
    // Declare and initialize an array
    b := [3]string{"a", "b", "c"}
    fmt.Println("Array b:", b)      // Output: Array b: [a b c]
}
```

---

### 2. Slices: Dynamic and Powerful

A **Slice** is a dynamically-sized, flexible view into the elements of an array. Slices are the common way to manage collections in Go.

#### A. Creating a Slice

You can create a slice by _slicing_ an existing array, using a literal declaration, or using the built-in `make` function.

Go

```
// Literal declaration (looks like an array, but without the size)
s := []string{"red", "green", "blue"} 

// Using the 'make' function: make([]T, len, cap)
// Creates a slice of length 3 and capacity 5
z := make([]int, 3, 5) 
```

#### B. Appending to a Slice

The built-in `append` function is used to add new elements. If the underlying array is full, Go automatically creates a new, larger array and moves the elements over.

Go

```
package main

import "fmt"

func main() {
    // Start with an empty slice
    colors := []string{} 
    
    // Append elements dynamically
    colors = append(colors, "Purple")
    colors = append(colors, "Orange", "Yellow") // Append multiple
    
    fmt.Println("Slice:", colors) // Output: Slice: [Purple Orange Yellow]
    fmt.Println("Length:", len(colors)) // Length: 3
}
```

---

### 3. Maps: Key-Value Pairs

A **Map** is Go's built-in hash map (dictionary). It stores unordered key-value pairs, where the keys must all be the same type, and the values must all be the same type.

#### Example: Declaring and Using a Map

Go

```
package main

import "fmt"

func main() {
    // Syntax: map[KeyType]ValueType
    // Literal declaration:
    employees := map[string]int{
        "Alice": 101,
        "Bob": 102,
    }

    // Accessing a value
    fmt.Println("Bob's ID:", employees["Bob"]) // Output: Bob's ID: 102

    // Adding a new entry
    employees["Charlie"] = 103
    
    // Checking for existence (The comma ok idiom)
    id, ok := employees["David"]
    
    if ok {
        fmt.Println("David's ID is:", id)
    } else {
        fmt.Println("David not found.") // Executes this
    }
    
    // Deleting an entry
    delete(employees, "Alice")
    fmt.Println("Map after delete:", employees) // Output: Map after delete: map[Bob:102 Charlie:103]
}
```

---

### ðŸ”— Reference

- **Go Tour - Slices:** [https://go.dev/tour/moretypes/7](https://www.google.com/search?q=https://go.dev/tour/moretypes/7)
    
- **Go Tour - Maps:** [https://go.dev/tour/moretypes/19](https://go.dev/tour/moretypes/19)