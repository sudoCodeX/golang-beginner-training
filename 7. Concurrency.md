## âš¡ Chapter 7: Concurrency (Goroutines and Channels)

Go was built for concurrency. It uses two powerful concepts to manage multiple tasks simultaneously without the complexity of traditional multi-threading: **Goroutines** and **Channels**.

### 1. Goroutines: Lightweight Threads

A **Goroutine** is a lightweight, independently executing function. They are cheaper to create and manage than traditional operating system threads, allowing Go programs to run thousands of them efficiently.

To start a function as a Goroutine, simply prepend the function call with the **`go`** keyword.

#### Example: Starting a Goroutine

Go

```
package main

import (
	"fmt"
	"time" // Used to pause the main function
)

func say(s string) {
	for i := 0; i < 3; i++ {
		time.Sleep(100 * time.Millisecond) // Wait a bit
		fmt.Println(s)
	}
}

func main() {
	// 1. Run 'say("world")' as a new Goroutine
	go say("world") 

	// 2. Run 'say("hello")' in the main Goroutine
	say("hello") 
	
	// Notice how "world" and "hello" output is interleaved!
	// The main function will exit when 'say("hello")' finishes, 
	// often cutting off the 'world' Goroutine if we didn't add the sleeps.
}
/*
Possible Output (interleaved):
hello
world
hello
world
hello
world
*/
```

**ðŸ”¥ Key Takeaway:** The Goroutine runs **concurrently** with the main function, leading to interleaved output.

---

### 2. Channels: Communicating Between Goroutines

A **Channel** provides a way for Goroutines to **communicate** and **synchronize**. Think of a channel as a pipe where one Goroutine can send a value and another can receive it.

#### A. Channel Declaration and Operations

1. **Declaration:** `ch := make(chan type)`
    
2. **Sending:** `ch <- value` (Send `value` into channel `ch`)
    
3. **Receiving:** `value := <-ch` (Receive a value from `ch` and assign it to `value`)
    

#### B. Example: Using Channels for Coordination

Go

```
package main

import "fmt"

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	// Send the calculated sum to the channel c
	c <- sum 
}

func main() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}
	
	// Create a new channel of type int
	c := make(chan int) 
	
	// Split the work:
	// Goroutine 1: Sum the first half
	go sum(numbers[:len(numbers)/2], c) // [1, 2, 3, 4]
	
	// Goroutine 2: Sum the second half
	go sum(numbers[len(numbers)/2:], c) // [5, 6, 7, 8]
	
	// Receive results from the channel (this is a BLOCKING operation)
	x := <-c // Waits for the first sum result
	y := <-c // Waits for the second sum result
	
	fmt.Println("Result 1:", x) // Result 1: 10 (1+2+3+4)
	fmt.Println("Result 2:", y) // Result 2: 26 (5+6+7+8)
	fmt.Println("Total:", x+y)  // Total: 36
}
```

**ðŸ”¥ Key Concept:** When a Goroutine tries to send data to a channel, it **blocks** until another Goroutine is ready to receive it. This ensures automatic synchronization without explicit locks!

---

### ðŸ”— Reference

- **Go Tour - Goroutines:** [https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1)
    
- **Go Tour - Channels:** [https://go.dev/tour/concurrency/2](https://go.dev/tour/concurrency/2)