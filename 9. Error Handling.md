## ðŸš« Chapter 9: Error Handling, `defer`, `panic`, and `recover`

Go's philosophy on errors is to handle them explicitly, rather than relying on exceptions. It also provides mechanisms for ensuring cleanup and dealing with fatal errors.

### 1. Explicit Error Handling

As shown in Chapter 4, Go functions return errors as a regular value (usually the last return value). **Always check the error!**

#### Example: File Operations

Go

```
package main

import (
    "fmt"
    "os"
)

func main() {
    // os.Open returns a pointer to a file (*os.File) and an error (error)
    f, err := os.Open("non_existent_file.txt") 
    
    // Check if the error value is NOT nil
    if err != nil {
        // Output the error and stop execution gracefully
        fmt.Println("Error opening file:", err) 
        return
    }
    
    // Only if err is nil, proceed with file operations
    fmt.Println("File opened successfully:", f.Name())
    // We would close the file here (see 'defer' below)
}
// Output: Error opening file: open non_existent_file.txt: no such file or directory
```

---

### 2. `defer`: Cleanup Guaranteed

The **`defer`** keyword schedules a function call to be executed immediately before the surrounding function returns. This is essential for resource cleanup (like closing files or database connections).

Go

```
package main

import "fmt"

func exampleDefer() {
    // This will be executed LAST, just before exampleDefer returns.
    defer fmt.Println("3. Cleanup complete.") 
    
    // This will be executed SECOND. (Last-In, First-Out stack)
    defer fmt.Println("2. Second defer call.") 

    // This executes FIRST.
    fmt.Println("1. Starting function.") 
}

func main() {
    exampleDefer()
}
/*
Output:
1. Starting function.
2. Second defer call.
3. Cleanup complete.
*/
```

**Key Use Case:** Always `defer` the closing of files right after opening them to ensure they are closed regardless of errors.

Go

```
f, err := os.Open("data.txt")
if err != nil { /* handle error */ }
defer f.Close() // GUARANTEED to run when the surrounding function exits
```

---

### 3. `panic` and `recover`: Exceptional Cases

These are Go's built-in mechanisms for dealing with truly exceptional, unrecoverable runtime errors (like dereferencing a nil pointer or accessing an out-of-bounds slice index).

- **`panic`**: Stops the ordinary flow of control and begins unwinding the stack. Panics should **only** be used for situations that indicate a programming error or an unrecoverable system state.
    
- **`recover`**: A built-in function that is used inside a `defer` function to regain control of a panicking Goroutine. It converts the panic into an error value. This is rarely used in application code, primarily in library code to maintain robustness.
    

#### Example: Causing a Panic

Go

```
func main() {
    // This will cause a panic, as division by zero is not allowed
    // fmt.Println(10 / 0) 
    
    // Or, explicitly
    panic("Something terrible happened!") 
    
    // This line is never reached
    fmt.Println("End of program") 
}
```

---

### ðŸ”— Reference

- **Go Tour - Defer:** [https://go.dev/tour/flowcontrol/12](https://go.dev/tour/flowcontrol/12)
    
- **Go Blog - Error Handling:** [https://go.dev/blog/error-handling-and-go](https://go.dev/blog/error-handling-and-go)