## ‚ö° Communicating Sequential Processes (CSP) üó£Ô∏è

Channels are the core synchronization and communication mechanism in Go. They embody the idiom: **"Don't communicate by sharing memory; share memory by communicating."** A channel acts as a type-safe conduit or pipe through which Goroutines can send and receive values.

### Channel Declaration and Operations

Channels are a type themselves and must be initialized using the built-in `make` function.

|**Operation**|**Syntax**|**Description**|
|---|---|---|
|**Declaration**|`ch := make(chan dataType)`|Creates an unbuffered channel capable of transmitting `dataType`.|
|**Sending**|`ch <- value`|Sends a `value` into the channel `ch`. This operation **blocks** until another Goroutine is ready to receive.|
|**Receiving**|`value := <-ch`|Receives a value from the channel `ch`. This operation **blocks** until another Goroutine is ready to send.|

### Synchronization through Blocking

By default, channels are **unbuffered**. This means the sender and receiver must be ready at the same time for the transfer to occur. This built-in blocking is what makes channels an excellent tool for **synchronization** and orderly program execution.

#### Example: Channel for Synchronization

This example uses an unbuffered channel to wait for the `sum` Goroutine to complete its calculation and send the result before the `main` Goroutine proceeds.

Go

```
package main

import "fmt"

// This function sends its calculated sum through the channel c.
func sum(s []int, c chan int) {
	total := 0
	for _, v := range s {
		total += v
	}
	c <- total // Sender blocks here until main() receives the value
}

func main() {
	numbers := []int{1, 2, 3, 4, 5}
	c := make(chan int) // Unbuffered channel of type int
	
	go sum(numbers, c) // Start calculation concurrently
	
	// Receiver blocks here until the sum Goroutine sends the value
	result := <-c 
	
	fmt.Println("The total sum is:", result) // Output: The total sum is: 15
}
```

### The `range` and `close` Keywords

You can iterate over a channel using the `range` keyword. To signal that no more values will be sent, the sender must **`close`** the channel.

- **`close(ch)`**: Closes the channel. Subsequent sends will panic.
    
- **`range ch`**: Iterates until the channel is closed.
    

Go

```
// Example of closing a channel and ranging over it
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x+y
	}
	close(c) // Sender closes the channel
}

func main() {
	c := make(chan int, 10)
	go fibonacci(5, c)

	// Range loop receives values until the channel c is closed
	for i := range c {
		fmt.Println(i) 
	}
}
```

**Important:** Only the **sender** should ever close a channel.