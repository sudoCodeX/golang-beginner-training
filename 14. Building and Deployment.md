## üö¢ Chapter 14: Building and Deployment

Go is famous for creating **statically linked binaries**, which simplifies deployment immensely. This chapter covers the essential commands for building, cross-compiling, and setting environment variables.

### 1. The `go build` Command

The `go build` command compiles your source code and its dependencies. Unlike interpreted languages, the output is a single, standalone executable file.

#### A. Basic Build

Bash

```
# Builds an executable in the current directory (named after the folder/package)
go build 
```

#### B. Output Naming

Use the `-o` flag to specify the desired name and location of the binary.

Bash

```
# Builds the executable and names it 'my-app'
go build -o my-app 
```

### 2. Cross-Compilation: The Go Advantage üåç

One of Go's killer features is its ability to easily **cross-compile** a binary for a different operating system (OS) and architecture without needing that target environment. This is controlled by two environment variables:

- **`GOOS`**: The target operating system (e.g., `linux`, `windows`, `darwin`).
    
- **`GOARCH`**: The target architecture (e.g., `amd64`, `arm64`).
    

#### Example: Building for Linux (64-bit)

To build a binary that runs on a standard Linux server, run:

Bash

```
# Set GOOS and GOARCH, then build
GOOS=linux GOARCH=amd64 go build -o my-app-linux
```

The resulting `my-app-linux` file is ready to be moved to any standard Linux machine.

#### Example: Building for macOS (Apple Silicon)

Bash

```
GOOS=darwin GOARCH=arm64 go build -o my-app-mac-arm
```

### 3. Build Tags and Conditional Compilation

**Build Tags** (or _Constraints_) allow you to include or exclude specific files during the build process based on OS, architecture, or custom flags.

You place a build tag comment at the top of a Go source file:

Go

```
// +build linux,amd64  // OLD (pre-Go 1.17)
//go:build linux && amd64 // NEW (Go 1.17+)

package main

// This file's code will ONLY be included when building for Linux AMD64
func initLinuxSystem() {
    // ... Linux specific setup code ...
}
```

### 4. Injecting Build Information

It's crucial for professional deployments to embed version information (like the Git commit hash, build date, etc.) into the executable. This is done using the `-ldflags` (linker flags) with the `-X` option.

Bash

```
# Example of injecting version and commit into variables in main package
VERSION="1.0.0"
COMMIT=$(git rev-parse --short HEAD)

go build -ldflags="-X main.Version=${VERSION} -X main.Commit=${COMMIT}" -o my-app
```

You must define the corresponding variables in your `main` package for this to work:

Go

```
// main.go
package main

var (
    Version string // Will be overridden by the linker
    Commit  string // Will be overridden by the linker
)

func main() {
    fmt.Println("App Version:", Version)
    fmt.Println("Git Commit:", Commit)
}
```

---

### üîó Reference

- **Go Documentation - Build Environment Variables:** [https://go.dev/cmd/go/#hdr-Environment_variables](https://www.google.com/search?q=https://go.dev/cmd/go/%23hdr-Environment_variables)
    
- **Go Documentation - Build Constraints:** [https://pkg.go.dev/cmd/go#hdr-Build_constraints](https://www.google.com/search?q=https://pkg.go.dev/cmd/go%23hdr-Build_constraints)