<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go (Golang) Comprehensive Master Guide</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Slate 50 */
        }
        /* Custom styles for rendered code blocks (created by marked.js) */
        #markdown-container pre code {
            display: block;
            background-color: #1e293b; /* Slate 800 */
            color: #f8fafc; /* Slate 50 */
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        /* Style for tables generated by marked.js */
        #markdown-container table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: white;
        }
        #markdown-container th, #markdown-container td {
            border: 1px solid #e2e8f0; /* Slate 200 */
            padding: 0.75rem 1rem;
            text-align: left;
        }
        #markdown-container thead th {
            background-color: #f1f5f9; /* Slate 100 */
            font-weight: 600;
            color: #475569; /* Slate 600 */
        }

        /* TOC Styles */
        .toc-link:hover {
            color: #0d9488; /* Teal 600 */
        }
        .active-link {
            font-weight: 600;
            color: #0f766e; /* Teal 700 */
            border-left: 3px solid #0f766e;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Main Grid Container -->
    <div class="flex flex-col lg:flex-row min-h-screen">

        <!-- Left Column: Table of Contents (Fixed) -->
        <nav id="toc" class="lg:w-72 bg-white border-b lg:border-r lg:border-b-0 shadow-lg lg:shadow-xl p-6 lg:sticky lg:top-0 h-16 lg:h-screen overflow-y-auto z-10">
            <h1 class="text-3xl font-extrabold text-teal-700 mb-6 hidden lg:block">Go Master Guide</h1>
            <h2 class="text-xl font-bold text-teal-700 block lg:hidden">Go Guide TOC</h2>
            
            <!-- TOC Links will be inserted here by JavaScript -->
            <ul id="toc-list" class="space-y-3 mt-4 hidden lg:block">
                <li class="text-sm text-slate-500">Loading content...</li>
            </ul>
        </nav>

        <!-- Right Column: Scrollable Content -->
        <main class="flex-grow p-6 md:p-10 lg:p-16 bg-slate-50">
            <article id="content-area" class="prose max-w-none">
                
                <header class="mb-12 border-b pb-6 border-teal-300">
                    <h1 class="text-4xl md:text-5xl font-extrabold text-slate-900">Go (Golang) Comprehensive Master Guide</h1>
                    <p class="text-xl text-slate-600 mt-2">A concise training and interview reference, dynamically loaded from Markdown.</p>
                </header>
                
                <!-- Markdown content will be rendered into this container -->
                <div id="markdown-container">
                    <p class="text-center text-lg text-slate-500">Loading guide content...</p>
                </div>

                <footer class="text-center pt-8 border-t border-slate-300">
                    <p class="text-sm text-slate-500">&copy; 2024 Go Master Guide. Built with a passion for simplicity.</p>
                </footer>

            </article>
        </main>
    </div>

    <script>
        // Path to the file containing the list of all Markdown files to load, in order.
        const manifestPath = 'DOC_FILES.txt'; 
        
        const contentContainer = document.getElementById('markdown-container');
        const tocList = document.getElementById('toc-list');
        const mainContentArea = document.getElementById('content-area');

                /**
         * Loads the file list from DOC_FILES.txt, then fetches and renders all Markdown content.
         */
        async function loadAndRenderContent() {
            let markdownFiles = [];

            try {
                // 1. Fetch file list from DOC_FILES.txt
                contentContainer.innerHTML = `<p class="text-center text-lg text-slate-500 animate-pulse">Fetching file list from ${manifestPath}...</p>`;
                console.log(`[INFO] 1. Starting documentation load. Manifest path: ${manifestPath}`);

                const fileListResponse = await fetch(manifestPath);
                if (!fileListResponse.ok) {
                    throw new Error(`Failed to load file list from ${manifestPath}. Status: ${fileListResponse.status}. Please ensure this file exists.`);
                }
                const fileListText = await fileListResponse.text();
                
                // Parse file names (one per line, filtering out empty lines and trimming whitespace)
                markdownFiles = fileListText.split('\n').map(s => s.trim()).filter(s => s.length > 0);
                
                if (markdownFiles.length === 0) {
                    throw new Error(`The file ${manifestPath} is empty or contains no valid file names.`);
                }

                console.log(`[INFO] 2. Manifest loaded successfully. Found ${markdownFiles.length} files:`, markdownFiles);

                contentContainer.innerHTML = `<p class="text-center text-lg text-slate-500 animate-pulse">Fetching ${markdownFiles.length} documentation files...</p>`;
                let combinedMarkdown = '';

                // 2. Create an array of fetch promises for the Markdown files
                const fetchPromises = markdownFiles.map(file => fetch(file).then(response => {
                    if (!response.ok) {
                        // If any single file fails, throw an error with the filename
                        console.error(`[ERROR] Failed to load individual file: ${file}. Status: ${response.status}`);
                        throw new Error(`Failed to load file: ${file} (Status: ${response.status})`);
                    }
                    console.log(`[INFO] 3. Successfully fetched: ${file}`);
                    return response.text();
                }));

                // 3. Wait for all files to load
                const fileContents = await Promise.all(fetchPromises);
                
                // Helper to clean potential Byte Order Mark (BOM) which causes syntax errors
                const cleanContent = (content) => content.replace(/^\ufeff/, '');

                // 4. Combine contents into a single markdown string after cleaning
                combinedMarkdown = fileContents.map(cleanContent).join('\n\n\n'); 
                console.log("[INFO] 4. All files combined. Starting Markdown parsing.");

                // 5. Set up marked options to generate IDs for headers
                marked.use({
                    gfm: true,
                    headerIds: true,
                });

                // 6. Render combined Markdown to HTML
                const htmlContent = marked.parse(combinedMarkdown);
                contentContainer.innerHTML = htmlContent;
                
                // 7. Rebuild TOC and setup observers
                buildTableOfContents();
                console.log("[INFO] 5. Rendering complete. TOC built.");

            } catch (error) {
                console.error("[FATAL ERROR] Error loading or rendering Markdown:", error);
                
                // FIX: Using a single Template Literal (backticks) for robust, multi-line HTML assignment
                contentContainer.innerHTML = `
                    <p class="text-red-600 font-bold">Error: Could not load the documentation.</p>
                    <p>The system failed to load content. Check the console for details, specifically errors related to:
                        <ul>
                            <li><code>${manifestPath}</code> not found, or</li>
                            <li>One of the ${markdownFiles.length} files listed in the manifest is missing or has a path mismatch.</li>
                        </ul>
                    </p>
                    <pre class="bg-red-50 p-4 rounded-lg text-sm text-red-800 mt-4">${error.message}</pre>
                `;
                
                tocList.innerHTML = `<li class="text-sm text-red-500">Error loading guide.</li>`;
            }
        }



        /**
         * Builds the Table of Contents dynamically based on H2 and H4 elements
         * generated by the Markdown parser.
         */
        function buildTableOfContents() {
            // Clear placeholder/old TOC
            tocList.innerHTML = '';
            
            // Find all H2 and H4 elements dynamically created by marked.js
            // These elements automatically have IDs generated from their text content
            const headers = contentContainer.querySelectorAll('h2, h4');
            let currentParentUl = null;

            headers.forEach(header => {
                const level = header.tagName.toLowerCase(); // h2 or h4
                const id = header.id;
                const linkText = header.textContent;
                
                if (level === 'h2') {
                    // Main Chapter (H2)
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = \`#\${id}\`;
                    a.className = 'toc-link block pl-2 border-l-2 border-transparent text-sm';
                    a.textContent = linkText;
                    li.appendChild(a);
                    tocList.appendChild(li);
                    
                    // Prepare for sub-links (UL)
                    const subUl = document.createElement('ul');
                    subUl.className = 'pl-4 space-y-1 mt-1 text-xs text-slate-500';
                    li.appendChild(subUl);
                    currentParentUl = subUl;
                    
                } else if (level === 'h4' && currentParentUl) {
                    // Sub-section (H4) - only nest if we found an H2 parent
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = \`#\${id}\`;
                    a.className = 'toc-link block';
                    a.textContent = linkText;
                    li.appendChild(a);
                    currentParentUl.appendChild(li);
                }
            });

            // Show TOC on desktop after loading
            tocList.classList.remove('hidden');

            // Re-initialize the Intersection Observer after building TOC
            initializeObserver();
        }

        /**
         * Sets up the Intersection Observer to highlight the active TOC link
         * based on the user's scroll position.
         */
        function initializeObserver() {
            // Find all dynamically created TOC links and content headers
            const tocLinks = document.querySelectorAll('#toc-list .toc-link');
            const contentSections = contentContainer.querySelectorAll('h2[id], h4[id]');

            if (contentSections.length === 0) return;

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const id = entry.target.getAttribute('id');
                    const link = document.querySelector(\`#toc-list a[href="#\${id}"]\`);
                    
                    if (link) {
                        // Logic to activate links when they cross the 20% viewport threshold
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.2) {
                            // Clear all active states first
                            tocLinks.forEach(l => { l.classList.remove('active-link'); });
                            
                            // Set the current link active
                            let currentLink = link;
                            currentLink.classList.add('active-link');
                            
                            // If it's a sub-section (h4) link, also highlight its main chapter (h2) link
                            const parentUl = currentLink.closest('ul');
                            if (parentUl && parentUl.classList.contains('pl-4')) {
                                const parentChapterLi = parentUl.closest('li');
                                if (parentChapterLi) {
                                    const parentChapterLink = parentChapterLi.querySelector(':scope > a');
                                    if (parentChapterLink) {
                                        parentChapterLink.classList.add('active-link');
                                    }
                                }
                            }
                        }
                    }
                });
            }, { 
                rootMargin: '0px 0px -80% 0px', // Highlight links when section is near the top
                threshold: 0.2 
            });

            contentSections.forEach(section => {
                observer.observe(section);
            });
        }

        // Start the loading process when the page is fully loaded
        document.addEventListener('DOMContentLoaded', loadAndRenderContent);
    </script>
</body>
</html>
