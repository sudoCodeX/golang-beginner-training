## âš¡ Mutexes (`sync.Mutex`): Protecting Shared Memory ðŸ”’

While channels are the idiomatic way to handle concurrency in Go, sometimes Goroutines must directly access and modify shared variables (like a global counter or a shared map). When memory is shared, you must use synchronization primitives to prevent **data races**. The primary tool for this is the **Mutex** (Mutual Exclusion lock).

### The Data Race Problem

A **data race** occurs when two or more Goroutines access the same memory location concurrently, and at least one of the accesses is a write, and they don't use any explicit synchronization. This leads to unpredictable, erroneous results.

To detect this, always run your tests and builds with the race detector enabled: `go run -race your_file.go` or `go test -race`.

### Mutex Operations

A Mutex is a structure that provides two basic methods to guard a critical section of code (the part accessing shared memory):

|**Method**|**Purpose**|**Description**|
|---|---|---|
|**`Lock()`**|Acquire Lock|Locks the mutex. If the mutex is already locked by another Goroutine, the calling Goroutine **blocks** until the lock is released.|
|**`Unlock()`**|Release Lock|Unlocks the mutex. This must be called by the Goroutine that locked it. **Failing to unlock** the mutex leads to a permanent deadlock.|

### Example: Preventing a Data Race

In this example, the `safeIncrement` function uses a Mutex to ensure only one Goroutine can modify the shared `counter` variable at any given time.

Go

```
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex // Declare a Mutex to protect 'counter'
)

func safeIncrement() {
    mu.Lock()   // 1. Acquire the lock (start of the critical section)
    defer mu.Unlock() // 2. Release the lock when the function exits (idiomatic)
    
    // Only one Goroutine can execute this line at a time
    counter++ 
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            safeIncrement() // Access shared counter safely
        }()
    }

    wg.Wait()
    fmt.Println("Final Counter (safe):", counter) // Output will reliably be: 1000
}
```

**ðŸ”¥ Best Practice:** Always use **`defer mu.Unlock()`** immediately after calling `mu.Lock()`. This guarantees the lock is released when the function finishes, even if it panics.

### `RWMutex` (Read-Write Mutex)

For data that is read much more often than it is written, Go provides **`sync.RWMutex`**.

- **Multiple Readers:** It allows multiple Goroutines to hold the **Read Lock** simultaneously.
    
- **Exclusive Writer:** The **Write Lock** (via `Lock()` and `Unlock()`) is exclusive, blocking all other readers and writers. This provides better performance in read-heavy scenarios.