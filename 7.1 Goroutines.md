## ⚡ Goroutines: The Engine of Concurrency ⚙️

Concurrency in Go is built on **Goroutines**—lightweight, independently executing functions. They are the core mechanism for running multiple tasks seemingly simultaneously.

### What is a Goroutine?

A Goroutine is _not_ a traditional operating system (OS) thread. Instead, the Go runtime multiplexes many Goroutines onto a smaller number of OS threads. This makes them incredibly **cheap** in terms of memory (starting with only a few KB of stack space) and CPU cost, allowing Go programs to efficiently handle thousands of concurrent tasks.

### Starting a Goroutine

To launch a function as a Goroutine, simply prepend the function call with the **`go`** keyword. The function then runs **concurrently** with the calling code.

#### Example: Starting Concurrent Tasks

In this example, `say("world")` starts immediately but runs in parallel with `say("hello")` in the main Goroutine.

Go

```
package main

import (
	"fmt"
	"time" 
)

func say(s string) {
	// Loop 3 times to clearly show the interleaved output
	for i := 0; i < 3; i++ {
		time.Sleep(50 * time.Millisecond) // Wait a brief moment
		fmt.Println(s)
	}
}

func main() {
	// Launches 'say("world")' as a separate, concurrent Goroutine
	go say("world") 
	
	// 'say("hello")' runs on the main Goroutine
	say("hello")    
}
/*
Possible Output (note the interleaved order):
hello
world
hello
world
hello
world
*/
```

### Goroutine Lifecycle

- **Start:** Using the `go` keyword.
    
- **Execution:** The Goroutine runs until the function returns.
    
- **Main Goroutine:** If the **`main`** function returns, the program exits immediately, and all other Goroutines are **terminated**, regardless of whether they have completed their work. This is why synchronization tools (like channels or `WaitGroup`) are necessary to wait for concurrent tasks.