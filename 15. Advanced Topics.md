## ðŸ§  Chapter 15: Advanced Topics and Design Patterns

This chapter briefly introduces concepts and patterns frequently used in larger, more complex Go applications.

### 1. Context (`context.Context`)

The `context` package is a fundamental part of concurrent Go development. It is used to carry **deadlines, cancellation signals, and request-scoped values** across API boundaries and between Goroutines.

- **Usage:** It is always passed as the **first argument** to a function.
    
- **Purpose:** Essential for gracefully cancelling long-running operations (like database queries or HTTP requests) when they are no longer needed, preventing resource leaks.
    

Go

```
package main

import (
    "context"
    "time"
    "fmt"
)

func fetch(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("Fetch completed!")
    case <-ctx.Done(): // Checks for a cancellation signal
        fmt.Println("Fetch cancelled:", ctx.Err())
    }
}

func main() {
    // Context with a timeout of 1 second
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel() // Always call cancel to release resources

    fetch(ctx)
}
// Output (likely): Fetch cancelled: context deadline exceeded
```

### 2. Generics (Go 1.18+)

Generics allow you to write functions and data structures that work correctly with **multiple types** without sacrificing type safety or requiring the use of `interface{}` (or `any`).

- **Type Parameter:** Functions and types now accept type parameters in square brackets (e.g., `[T any]`).
    
- **Constraint:** The type parameter is restricted by a **constraint** (e.g., `any` for any type, or `comparable` for types that can use `==` or `!=`).
    

Go

```
// A generic function that works for any type 'T' that is comparable
func Contains[T comparable](slice []T, element T) bool {
    for _, v := range slice {
        if v == element {
            return true
        }
    }
    return false
}
```

### 3. Design Patterns (Common Go Idioms)

While Go avoids classical OOP inheritance, several patterns are common:

- **Option Pattern:** Used for creating complex objects with many optional configuration fields. Instead of one large constructor, you pass a variadic number of configuration functions (options).
    
- **Functional Options:** Used for clean and extensible function configuration.
    
    Go
    
    ```
    // Instead of: NewServer(host, port, timeout, maxConns, ...)
    // Use: NewServer(options... Option)
    ```
    
- **Decorator Pattern:** Implemented easily using **function wrappers** (especially common in middleware for HTTP handlers) to add pre- or post-processing logic.
    
- **Mutex (`sync.Mutex`):** The primary synchronization primitive used to protect shared data when multiple Goroutines access it concurrently. Used to enforce the **"Don't communicate by sharing memory; share memory by communicating"** idiom (Chapter 7) when channels are overkill.
    

### 4. Code Generation

Go uses code generation (tools that write Go code) for tasks that would require boilerplate in other languages, such as:

- **Stringers:** Using `go generate` and `stringer` to automatically create `String()` methods for custom types (like enums).
    
- **Mocks/Fakes:** Generating mock interfaces for testing.
    

---

### ðŸ”— Reference

- **Go Documentation - Context:** [https://go.dev/blog/context-and-semantics](https://www.google.com/search?q=https://go.dev/blog/context-and-semantics)
    
- **Go Documentation - Generics:** [https://go.dev/doc/tutorial/generics](https://go.dev/doc/tutorial/generics)