## âš¡ Buffered Channels and Deadlocks ðŸ›‘

While unbuffered channels guarantee synchronization, **buffered channels** offer a way to loosen that coupling by allowing a fixed number of values to be stored temporarily. Understanding the limits of buffering is crucial to avoid the major pitfall of concurrency: **deadlocks**.

### Buffered Channels

A buffered channel is created by supplying a capacity (an integer) as the second argument to `make`.

- **Creation:** `ch := make(chan dataType, capacity)`
    

The channel acts like a queue of fixed size.

- **Sending:** Blocks only when the buffer is **full**.
    
- **Receiving:** Blocks only when the buffer is **empty**.
    

#### Example: Sending to a Buffered Channel

Go

```
package main

import "fmt"

func main() {
	// Create a buffered channel of capacity 2
	messages := make(chan string, 2) 

	// These sends do NOT block because the buffer has space
	messages <- "Fast" 
	messages <- "Data" 

	fmt.Println("Sent two messages.")
	
	// If we tried: messages <- "Blocker", the program would block/wait here.

	// Receives work as normal, but don't block unless the buffer is empty
	fmt.Println("Received:", <-messages) // Output: Received: Fast
	fmt.Println("Received:", <-messages) // Output: Received: Data
}
```

**Use Case:** Buffered channels are useful when you need to limit the rate or number of simultaneous work items (like a worker pool) without forcing every sender to wait for every receiver immediately.

---

### Deadlocks: The Concurrency Killer

A **deadlock** occurs when a set of Goroutines are waiting for each other indefinitely, resulting in a program freeze. The Go runtime will eventually detect this permanent blockage and halt the program with a panic: `all goroutines are asleep - deadlock!`.

#### Example: Unbuffered Deadlock

An unbuffered channel requires both a sender and a receiver. If the main Goroutine tries to send a value without a concurrent Goroutine ready to receive it, the program deadlocks.

Go

```
package main

// WARNING: This code causes a deadlock!
func main() {
	c := make(chan int)

	// The send blocks immediately. Since no receiver is ever launched, 
	// the main Goroutine hangs forever.
	c <- 1 

	fmt.Println("This line is never reached.")
}
// Runtime Panic: fatal error: all goroutines are asleep - deadlock!
```

#### Example: Buffered Deadlock

A deadlock can also occur with buffered channels if you try to send more values than the channel's capacity allows, without any Goroutine concurrently receiving.

Go

```
package main

// WARNING: This code also causes a deadlock!
func main() {
	c := make(chan int, 1)

	c <- 1 // Success (buffer capacity is 1)
	
	// The send blocks because the buffer is full (capacity 1).
	// Since no other Goroutine will ever empty it, the program deadlocks.
	c <- 2 

	fmt.Println("Still never reached.")
}
```