## âœ… Chapter 10: Unit Testing (The Go Test)

Testing is a fundamental part of the Go ecosystem. The language's built-in `testing` package and the `go test` command make it simple to ensure code quality and prevent regressions.

### 1. Naming Conventions

Go relies on strict file and function naming conventions to identify tests:

- **Test File:** Create a file ending with **`_test.go`** in the **same package** as the code you are testing.
    
    - _Example:_ For `math.go`, create `math_test.go`.
        
- **Test Function:** The function name must start with **`Test`** and take a single argument: `*testing.T`.
    
    - _Example:_ `func TestAdd(t *testing.T) { ... }`
        

### 2. Basic Unit Test Structure

A unit test follows a simple pattern: setup, execution, and assertion.

#### Example: Testing an `Add` function

Assume you have a function `Add(a, b int) int` in `math.go`.

Go

```
// math_test.go
package math

import "testing" // The standard testing package

func TestAdd(t *testing.T) {
    // 1. Arrange (Setup)
    a, b := 2, 3
    want := 5
    
    // 2. Act (Execution)
    got := Add(a, b) 

    // 3. Assert (Verification)
    if got != want {
        // t.Errorf reports an error but continues the test
        t.Errorf("Add(%d, %d) got %d, wanted %d", a, b, got, want) 
        // t.Fatalf would report an error and stop the test immediately
    }
}
```

### 3. Running Tests

Execution is handled directly by the Go toolchain. Run this command in the directory containing your code:

Bash

```
# Run all tests in the current package
go test 

# Run tests verbosely (shows results for all tests, not just failed ones)
go test -v 

# Run a specific test function (e.g., only TestAdd)
go test -run TestAdd
```

### 4. Best Practice: Table-Driven Tests

For functions with multiple scenarios (different inputs and expected outputs), **table-driven tests** are the idiomatic and most efficient approach in Go.

Go

```
func TestSubtract(t *testing.T) {
    // Define a slice of structs, where each struct is a test case
    tests := []struct {
        name string
        a    int
        b    int
        want int
    }{
        {"Basic Subtraction", 10, 5, 5},
        {"Zero Result", 5, 5, 0},
        {"Negative Result", 5, 10, -5},
    }

    // Loop through the table and run each case as a subtest
    for _, tt := range tests {
        // t.Run allows you to execute subtests with descriptive names
        t.Run(tt.name, func(t *testing.T) {
            got := Subtract(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Subtract() got %v, want %v", got, tt.want)
            }
        })
    }
}
```

This structure makes it easy to add new test cases without duplicating setup code.

---

### ðŸ”— Reference

- **Go Documentation - Writing tests:** [https://go.dev/doc/tutorial/add-a-test](https://go.dev/doc/tutorial/add-a-test)
    
- **Go Package `testing`:** [https://go.dev/pkg/testing/](https://go.dev/pkg/testing/)